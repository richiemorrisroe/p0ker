- In which I write a card deck
- Plan is to implement poker
- And then potentially some bots.

- Because I am a lazy, lazy man I'm going to start with the CardDeck from fluent python.

#+BEGIN_SRC python
import collections

Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spades diamonds clubs hearts'.split()

    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits
                       for rank in self.ranks]
    def __len__(self):
        return len(self._cards)
    def __getitem__(self, position):
        return self._cards[position]

#+END_SRC

- So this creates a deck, and each card is just an element of the deck
- This isn't really what I want, though there are some good ideas that I can steal from it.

#+BEGIN_SRC python :tangle deck.py
from enum import Enum, IntEnum
import random as random
import collections as collections



class Suit(Enum):
    SPADES = 1
    CLUBS = 2
    DIAMONDS = 3
    HEARTS = 4


class Rank(IntEnum):
    TWO = 2
    THREE = 3
    FOUR = 4
    FIVE = 5
    SIX = 6
    SEVEN = 7
    EIGHT = 8
    NINE = 9
    TEN = 10
    JACK = 11
    QUEEN = 12
    KING = 13
    ACE = 14


def random_choice(upper, lower):
    x = random.randint(upper, lower)
    return x

def random_suit(Suit : Suit) -> Suit:
    choice = Suit(random_choice(1, 4))
    return choice

def random_rank(Rank: Rank) -> Rank:
    choice = Rank(random_choice(2, 13))
    return choice


Card = collections.namedtuple("Card", ['rank', 'suit'])


#+END_SRC



- So, here we create two Enums, Rank and Suit
- A particular combination of these makes up a card
- However, the deck is probably the right level of abstraction for my purposes
  - It enforces uniqueness of cards
  - It provides a convenient target for methods (shuffle, deal)

- I probably need a Hand object, which consists of 1-5 cards
- So we can re-use some of the fluent python code, with our new Rank and Suit enums

#+BEGIN_SRC python :session :tangle deck.py
from random import shuffle

class FirstDeck:
    def __init__(self):
        self._cards = [Card(rank, suit) for suit in Suit
                       for rank in Rank]
    def __len__(self):
        return len(self._cards)
    def __getitem__(self, position):
        return self._cards[position]

    def shuffle(self):
        cards = shuffle(self._cards)

    def deal(self):
        card = self._cards.pop(0)
        return card

#+END_SRC
- Ah yes, I should probably have finished the card implementation
- TDD anyone?
#+BEGIN_SRC python :session
Card = collections.namedtuple("Card", ['rank', 'suit'])
#+END_SRC

- After some dicking around with classes for card, I ended up back with a namedtuple
- i'll change this, but not now.
- I need to shuffle the deck
- Let's steal more code from fluent python! (it was shuffle, see above)

#+BEGIN_SRC python :session :tangle deck.py
player1 = []
player2 = []
player3 = []
players = [player1, player2, player3]
mydeck = FirstDeck()
mydeck.shuffle()
for i in range(0, 5):
    for player in players:
        card = mydeck.deal()
        player.append(card)

suits = []
ranks = []
for card in player3:
    suits.append(card.suit)
    ranks.append(card.rank)

for suit in Suit:
    print(suits.count(suit))

rcount =[]
for rank in Rank:
    rcount.append(ranks.count(rank))

suits_uc = { "♠":1, "♣":2, "♥":4, "♦":8 }
#+END_SRC

- This is just messing around with the hands
- I actually need to change my implementation of rank, to use IntEnum
- this will allow for integer comparisons of the values, which I need
- IntEnum away

#+BEGIN_SRC python :session
Ace = Rank(14)
Deuce = Rank(2)
Ace < Deuce
Ace > Deuce
#+END_SRC
- So now we have comparisons across ranks
- As per official rules, we don't need these for suits
** Scoring Hands

- Reasonably involved.
- I started [[https://stackoverflow.com/questions/10363927/the-simplest-algorithm-for-poker-hand-evaluation][here]], found an [[https://www.codeproject.com/Articles/569271/A-Poker-hand-analyzer-in-JavaScript-using-bit-math][insane bitmath]] implementation, but my own thoughts were most usefully inspired by [[https://people.eecs.berkeley.edu/~bh/ssch15/poker.html][here]] (i love that its a project building on previous work but completely different)
- So most of the hands depend on either suits or ranks
- We have same number suits (two, three four of a kind, two-pair, full house)
- rank based (straight)
- suit based (flush)
- rank and suit based (royal flush)
- ideally we want a continuous number to optimise against, but we'll leave that alone for now.

- Official rules can be found [[https://www.pagat.com/poker/rules/ranking.html][here]]

#+BEGIN_SRC python :session :tangle deck.py
rankdict = dict.fromkeys(Rank)

for each in ranks:
    print(each.name)
def split_cards(hand):
    suits =[]
    ranks =[]
    for each in hand:
        suits.append(each.suit)
        ranks.append(each.rank)
    return suits, ranks



def count(ranks):
    rdict = dict.fromkeys(ranks)
    for each in ranks:
        if rdict[each]:
            rdict[each] += 1
        if not rdict[each]:
            rdict[each] = 1
    return rdict

def anyrep(ranks):
    origlen = len(ranks)
    uniquelen = len(set(ranks))
    if origlen == uniquelen:
        return False
    else:
        return True

def find_repeated_cards(ranks):
    res = []
    counts = count(ranks)
    for k, v in counts.items():
        if v >= 2:
            res.append((k, v))
    return res


def is_straight(ranks):
    ranks.sort()
    count = 0
    for i, rank in enumerate(ranks):
        if ranks[i+1] - rank == 1:
            count +=1
        if count==5:
            return True
        else:
            return False

def is_flush(suits):
    sc = count(suits)
    for k, v in sc.items():
        if v==5:
            return True
        else:
            return False

def make_straight(suit, start):
    hand = []
    if not start:
        start = 7
    for rank in range(8, 13):
        hand.append(Card(suit, Rank(rank)))
    return hand
#+END_SRC


- So the key when iterating over dicts is to use the items method (iteritems in Python 2)
- that may be the source of some of the problems I've been having with them
